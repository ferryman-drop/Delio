# TASK-004: Scheduler-FSM Bridge & Safety Hardening

## Мета (Objective)
Поточна реалізація `ReminderTool` та `scheduler.py` створює вразливість "Побічного Каналу" (Side-Channel), де асинхронні зворотні виклики (наприклад, нагадування, щоденні дайджести) оминають `StateGuard` та `FSMController`. Це призводить до стану гонитви (race condition), коли бот може "говорити" (Network Action), поки користувач перебуває в стані `PLAN` або `ACT`, що може пошкодити контекстне вікно або призвести до колізій веб-сокетів.

Мета полягає в тому, щоб перевести всі події, ініційовані Планувальником (Scheduler), під контроль `StateGuard` або спеціального протоколу `SystemEvent`.

## Обсяг (Scope)
- **Змінити**: `core/tools/reminder_tool.py` (Логіка callback)
- **Змінити**: `scheduler.py` (Використання глобального `bot_instance`)
- **Змінити**: `core/state_guard.py` (Додати `Action.SYSTEM_NOTIFICATION` або подібне за потреби)
- **Без змін**: Ядро `FSM` (decide/act/reflect), `ToolRegistry`.

## Інтерфейси та Контракти (Interfaces & Contracts)
- **Новий Абстрактний Інтерфейс**: `SchedulerCallback`, який забезпечує блокування (locking).
- **StateGuard**: Можливо, відкрити метод `try_acquire_notification_lock(user_id)` спеціально для високопріоритетних переривань.

## Обмеження (Constraints)
- **Неблокуючий (Non-Blocking)**: Потік Планувальника НЕ ПОВИНЕН блокуватися в очікуванні блокування користувача вічно. Якщо користувач зайнятий, нагадування має бути поставлено в чергу або повторено пізніше.
- **Архітектура**: Жодних прямих викликів `bot_instance.send_message` з інструментів. Вони повинні йти через керований шлюз.
- **Автономність**: Бот повинен "знати", що він надіслав нагадування (логування/пам'ять).

## Критерії Прийомки (Acceptance Criteria)
1.  **Безпека**: Якщо Користувач у стані `ACT` (наприклад, виконує тривалий інструмент), спрацювання Нагадування НЕ ламає стан і не вклинює текст у вивід.
2.  **Відповідність**: Усі повідомлення планувальника отримують блокування `StateGuard` перед відправкою.
3.  **Фолбек (Fallback)**: Якщо отримання блокування не вдалося (Користувач зайнятий), нагадування переходить у стан "Pending Notification" або повторюється через N секунд.
4.  **Тести**: Тест-кейс, що симулює "Зайнятого Користувача", який отримує нагадування.

## Стратегія Відкату (Rollback Strategy)
- Повернути `reminder_tool.py` до використання прямого виклику `bot_instance`.
## Статус Реалізації (Implementation Status) - Виконано ✅
1. **StateGuard**: Додано стан `NOTIFY` та метод `try_enter_notify` для безпечного переривання.
2. **ReminderTool**: Оновлено логіку `_send_notification`. Тепер використовує `try_enter_notify`. Якщо користувач зайнятий, нагадування переплановується на +30 секунд.
3. **Scheduler**: Додано функцію `safe_send_message`, яка забезпечує відправку повідомлень через `StateGuard` для дайджестів та брифінгів.
4. **Пам'ять**: Усі системні повідомлення тепер логуються в корострокову пам'ять (`old_memory`), щоб бот "пам'ятав", про що він повідомив.

### Змінені файли:
- `core/state.py`
- `core/state_guard.py`
- `core/tools/reminder_tool.py`
- `scheduler.py`
